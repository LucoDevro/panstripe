#' compare_pangenomes
#' 
#' @import cplm
#'
#' @description Compares pangenomes using anova
#'
#' @param fitA a `panfit` object generated by the `panstripe` function
#' @param fitB a `panfit` object generated by the `panstripe` function
#' @param family the family used by glm. One of 'Tweedie', 'Poisson', 'Gamma' or 'Gaussian'. (default='Tweedie')
#' @param ci_type the method used to calculate the bootstrap CI (default='bca'). See \link[boot]{boot.ci} for more details.
#' @param conf A scalar indicating the confidence level of the required intervals (default=0.95)
#' @param nboot the number of bootstrap replicates to perform (default=100)
#'
#' @return a list containing a summary of the comparison and the resulting `glm` model object
#'
#' @examples
#'
#' simA <- simulate_pan(rate=1e-2, ngenomes = 100, fn_error_rate=1, fp_error_rate=1)
#' simB <- simulate_pan(rate=1e-3, ngenomes = 100, fn_error_rate=1, fp_error_rate=1)
#' fitA <- panstripe(simA$pa, simA$tree, nboot=10, ci_type='perc')
#' fitA$summary
#' fitB <- panstripe(simB$pa, simB$tree, nboot=10, ci_type='perc')
#' fitB$summary
#' comp <- compare_pangenomes(fitA, fitB)
#'
#' @export
compare_pangenomes <- function(fitA, fitB, family="Tweedie", ci_type='bca', conf=0.95, nboot=100){
  
  # input checks
  if (class(fitA) != 'panfit') stop('fitA is not of class `panfit`!')
  validate_panfit(fitA)
  if (class(fitB) != 'panfit') stop('fitB is not of class `panfit`!')
  validate_panfit(fitB)
  
  #combine data
  dat <- purrr::imap_dfr(list(fitA, fitB), ~{
    tibble::add_column(.x$data, pangenome=LETTERS[[.y]], .before=1)
  })
  
  # check for all 0's
  if (sum(dat$acc[!dat$istip])==0) {
    warning("No gene gains/losses identified on internal branches! Separation may be a problem and setting method='Bayesian' method is recommended.")
  } else if (sum(dat$acc[dat$istip])==0) {
    warning("No gene gains/losses identified at phylogeny tips! Separation may be a problem and setting method='Bayesian' method is recommended.")
  }
  
  # fit model
  model <- stats::as.formula("acc ~ istip + core + depth + depth:pangenome + istip:pangenome + core:pangenome")
  m <- fit_tweedie(model, dat)
  
  s <- summary(m)$coefficients %>% 
    tibble::as_tibble(rownames = 'term')
  s <- s[s$term %in% c('istipTRUE:pangenomeB', 'core:pangenomeB', 'depth:pangenomeB'), , drop=FALSE]
  s$term <- gsub("[T:].*", "", s$term)
  colnames(s) <- c('term','estimate','std.error','statistic','p.value')
  
  # run bootstrap
  boot_reps <- boot::boot(dat, fit_model,
                          R = nboot,
                          stype='i',
                          tree=tree, model=model, family=family, boot_type='branch')
  
  ci <- purrr::map_dfr(which(grepl('.*pangenome.*', names(m$coefficients))), ~{
    df <- tibble::as_tibble(t(boot_ci_pval(boot_reps, index=.x, type=ci_type,
                                     theta_null=0, ci_conf=conf,
                                     transformation='identity')))
    df$term <- gsub("[T:].*", "", names(m$coefficients)[[.x]])
    return(df)
  })
  
  s$`bootstrap CI 2.5%` <- signif(as.numeric(ci$V1[match(s$term, ci$term)]), 5)
  s$`bootstrap CI 97.5%` <- signif(as.numeric(ci$V2[match(s$term, ci$term)]), 5)
  
  return(list(
    summary=s,
    model=m,
    data=dat
  ))
}

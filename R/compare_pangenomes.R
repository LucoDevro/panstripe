#' compare_pangenomes
#' 
#' @import cplm
#'
#' @description Compares pangenomes using anova
#'
#' @param fitA a `panfit` object generated by the `panstripe` function
#' @param fitB a `panfit` object generated by the `panstripe` function
#' @param family the family used by glm. One of 'Tweedie', 'Poisson', 'Gamma' or 'Gaussian'. (default='Tweedie')
#' @param ci_type the method used to calculate the bootstrap CI (default='norm'). See \link[boot]{boot.ci} for more details.
#' @param conf A scalar indicating the confidence level of the required intervals (default=0.95)
#' @param nboot the number of bootstrap replicates to perform (default=100)
#' @param boot_pvalue whether or not to calculate bootstrap p-values (default=FALSE)
#'
#' @return a list containing a summary of the comparison and the resulting `glm` model object
#'
#' @examples
#'
#' simA <- simulate_pan(rate=1e-3, ngenomes = 100, fn_error_rate=1, fp_error_rate=1, mean_trans_size=3)
#' simB <- simulate_pan(rate=1e-3, ngenomes = 100, fn_error_rate=1, fp_error_rate=1, mean_trans_size=6)
#' fitA <- panstripe(simA$pa, simA$tree, nboot=100, ci_type='norm')
#' fitA$summary
#' fitB <- panstripe(simB$pa, simB$tree, nboot=100, ci_type='norm')
#' fitB$summary
#' comp <- compare_pangenomes(fitA, fitB, ci_type='norm', boot_pvalue=TRUE)
#' comp$summary
#' plot_dist_params(list(L=fitA, S=fitB), boot_ci=TRUE)
#'
#' @export
compare_pangenomes <- function(fitA, fitB, family="Tweedie", ci_type='norm', conf=0.95, nboot=100, boot_pvalue=FALSE){
  
  # input checks
  if (class(fitA) != 'panfit') stop('fitA is not of class `panfit`!')
  validate_panfit(fitA)
  if (class(fitB) != 'panfit') stop('fitB is not of class `panfit`!')
  validate_panfit(fitB)
  
  #combine data
  dat <- purrr::imap_dfr(list(fitA, fitB), ~{
    tibble::add_column(.x$data, pangenome=LETTERS[[.y]], .before=1)
  })
  
  # check for all 0's
  if (sum(dat$acc[!dat$istip])==0) {
    warning("No gene gains/losses identified on internal branches! Separation may be a problem and setting method='Bayesian' method is recommended.")
  } else if (sum(dat$acc[dat$istip])==0) {
    warning("No gene gains/losses identified at phylogeny tips! Separation may be a problem and setting method='Bayesian' method is recommended.")
  }
  
  # fit model
  model <- stats::as.formula("acc ~ istip + core + depth + istip:core + depth:pangenome + istip:pangenome + core:pangenome")
  dmodel <- stats::as.formula("acc ~ pangenome")
  # dat$istip <- as.numeric(factor(dat$istip))-1
  # dat$pangenome <- as.numeric(factor(dat$pangenome))-1
  
  if (family=='Tweedie'){
    m <- fit_double_tweedie(model, dmodel=dmodel, data = dat)
    a <- anova.dglm.basic(m, tweedie.power = m$p)
  } else{
    m <- stats::glm(model, dat, family = family)
  }
  
  s <- summary(m)$coefficients %>% 
    tibble::as_tibble(rownames = 'term')
  s <- s[s$term %in% c('istipTRUE:pangenomeB', 'core:pangenomeB', 'depth:pangenomeB'), , drop=FALSE]
  s$term <- gsub("[T:].*", "", s$term)
  colnames(s) <- c('term','estimate','std.error','statistic','p.value')
  
  if (family=='Tweedie'){
    s <- s %>% tibble::add_row(
      term='dispersion model',
      estimate=NA,
      std.error=NA,
      statistic=a$Chisq,
      p.value=a$p.value)
  }
  
  # run bootstrap
  if (nboot>1){
    if (family=='Tweedie'){
      boot_reps <- boot::boot(dat, fit_double_model,
                              R = nboot,
                              stype='i',
                              strata=factor(dat$pangenome),
                              model=model, dmodel=dmodel)
    } else {
      boot_reps <- boot::boot(dat, fit_model,
                              R = nboot,
                              stype='i',
                              strata=factor(dat$pangenome),
                              model=model, family=family, boot_type='branch')
    }
    
    ci <- purrr::map_dfr(which(grepl('.*pangenome.*', names(m$coefficients))), ~{
      df <- as.data.frame(t(boot_ci_pval(boot_reps, index=.x, type=ci_type,
                                             theta_null=0, ci_conf=conf,
                                             transformation='identity', calc_pval = boot_pvalue)))
      df$term <- gsub("[T:].*", "", names(m$coefficients)[[.x]])
      return(df)
    })
    
    s$`bootstrap CI 2.5%` <- signif(as.numeric(ci$V1[match(s$term, ci$term)]), 5)
    s$`bootstrap CI 97.5%` <- signif(as.numeric(ci$V2[match(s$term, ci$term)]), 5)
    
    if (boot_pvalue){
      s$`bootstrap p-value` <- signif(as.numeric(ci$V3[match(s$term, ci$term)]), 5)
    }
    
  } else {
    boot_reps <- NULL
    s$`bootstrap CI 2.5%` <- NA
    s$`bootstrap CI 97.5%` <- NA
  }
  
  return(list(
    summary=s,
    model=m,
    data=dat
  ))
}


double_tweedie_llk <- function(p, model, data){
  dm <- dglm_mod(model, 
                 dformula =  ~ pangenome, 
                 data = data, 
                 family = statmod::tweedie(var.power = p, link.power = 0), 
                 tweedie.var.power=p)
  return(dm$m2loglik)
}

fit_double_tweedie <- function(model, dmodel, data){
  op <- stats::optimise(double_tweedie_llk, lower = 1, upper = 1.99, model=model, data=data)
  tm <- dglm_mod(formula = model,  
                 dformula =  dmodel,
                 data = data,
                 family = statmod::tweedie(var.power = op$minimum, link.power = 0), 
                 tweedie.var.power=op$minimum)
  tm$p <- op$minimum
  return(tm)
}

fit_double_model <- function(d, indices=NULL, model, dmodel){
  stopifnot(length(indices)==nrow(d))
  
  tdat <- d[indices,]
  tm <- fit_double_tweedie(model, dmodel = dmodel, data = tdat)
  coef <- c(tm$coefficients, tm$dispersion.fit$coefficients)
  
  return(coef)
}

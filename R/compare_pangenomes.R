#' compare_pangenomes
#' 
#' @import cplm
#'
#' @description Compares pangenomes using anova
#'
#' @param fitA a `panfit` object generated by the `panstripe` function
#' @param fitB a `panfit` object generated by the `panstripe` function
#' @param family the family used by glm. One of 'Tweedie', 'Poisson', 'Gamma' or 'Gaussian'. (default='Tweedie')
#' @param boot_type the method used to calculate the bootstrap CI (default='bca'). See \link[boot]{boot.ci} for more details.
#' @param conf A scalar indicating the confidence level of the required intervals (default=0.95)
#'
#' @return a list containing a summary of the comparison and the resulting `glm` model object
#'
#' @examples
#'
#' simA <- simulate_pan(rate=1e-3, ngenomes = 100, fn_error_rate=1, fp_error_rate=1)
#' simB <- simulate_pan(rate=1e-4, ngenomes = 100, fn_error_rate=1, fp_error_rate=1)
#' fitA <- panstripe(simA$pa, simA$tree, boot_type='norm', nboot=10)
#' fitA$summary
#' fitB <- panstripe(simB$pa, simB$tree, boot_type='norm', nboot=10)
#' fitB$summary
#' comp <- compare_pangenomes(fitA, fitB)
#'
#' @export
compare_pangenomes <- function(fitA, fitB, family="Tweedie", boot_type='bca', conf=0.95){
  
  # input checks
  if (class(fitA) != 'panfit') stop('fitA is not of class `panfit`!')
  validate_panfit(fitA)
  if (class(fitB) != 'panfit') stop('fitB is not of class `panfit`!')
  validate_panfit(fitB)

  
  if (nrow(fitA$ci_samples$t) < nrow(fitB$ci_samples$t)){
    bootC <- fitA$ci_samples
    bootC$t <- bootC$t-fitB$ci_samples$t[1:nrow(fitC$ci_samples$t),]
    bootC$t0 <- bootC$t0-fitB$ci_samples$t0
    coef <- fitA$summary$estimate - fitB$summary$estimate
  } else {
    bootC <- fitB$ci_samples
    bootC$t <- bootC$t-fitA$ci_samples$t[1:nrow(fitC$ci_samples$t),]
    bootC$t0 <- bootC$t0-fitA$ci_samples$t0
    coef <- fitB$summary$estimate - fitA$summary$estimate
  }
  names(coef) <- c('Intercept', 'tip', 'core', 'p', 'phi')
  
  
  # calculate CIs and p-values
  summary <- purrr::map_dfr(2:5, ~{
    transformation <- 'identity'
    # if (.x==4) transformation <- 'logit'
    # if (.x==5) transformation <- 'inverse'
    
    setNames(c(names(coef)[[.x]], coef[[.x]],
               boot_ci_pval(bootC, index=.x, type=boot_type,
                            theta_null=0, ci_conf=conf,
                            transformation=transformation)),
             c('term', 'estimate', 'p-value', '2.5%', '97.5%'))
    
  })
  summary$estimate <- signif(as.numeric(summary$estimate), 4)
  summary$`2.5%` <- signif(as.numeric(summary$`2.5%`), 5)
  summary$`97.5%` <- signif(as.numeric(summary$`97.5%`), 5)
  
  boot::boot.ci(bootC, type='perc', index = 2)
  
  #combine data
  dat <- purrr::imap_dfr(list(fitA, fitB), ~{
    tibble::add_column(.x$data, pangenome=LETTERS[[.y]], .before=1)
  })
  
  # check for all 0's
  if (sum(dat$acc[!dat$istip])==0) {
    warning("No gene gains/losses identified on internal branches! Separation may be a problem and setting method='Bayesian' method is recommended.")
  } else if (sum(dat$acc[dat$istip])==0) {
    warning("No gene gains/losses identified at phylogeny tips! Separation may be a problem and setting method='Bayesian' method is recommended.")
  }
  
  # fit model
  model1 <- stats::as.formula("acc ~ istip + core + pangenome")
  model2 <- stats::as.formula("acc ~ istip + core + pangenome + istip:pangenome")
  model3 <- stats::as.formula("acc ~ istip + core + pangenome + istip:pangenome + core:pangenome")
  if (is.character(family) && (family=="Tweedie")){
    fm <- function(form, data) {
      # this is a bit inefficient but makes it easy to use the standard anova function
      cfit <- cpglm(formula = form, data = data)
      stats::glm(formula = form, data = data, family = statmod::tweedie(var.power = cfit$p, link.power = 0))
    }
  } else {
    fm <- function(form, data) glm(formula = form, data = data, family=family)
  }
  m1 <- fm(model1, dat) 
  m2 <- fm(model2, dat) 
  m3 <- fm(model3, dat) 
  
  sm <- tibble::as_tibble(stats::anova(m1, m2, m3, test='F'))[2:3,] %>%
    tibble::add_column(term=c('tip', 'core'), .before=1)
  
  return(list(
    summary=sm,
    data=dat
  ))
}

ftest <- function(mod0, mod1){
  fstat <- (mod0$deviance - mod1$deviance)/(1*mod1$phi)
  df1 <- length(mod1$coefficients) - length(mod0$coefficients)
  p.value <- stats::pf(fstat, df1, mod1$df.residual, lower.tail = FALSE)
  return(tibble::tibble(F=fstat, pvalue=p.value))
}

